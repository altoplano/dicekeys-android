package org.dicekeys.crypto.seeded

/**
 * A Symmetric Key derived from a seed string and using options specified
 * via a [keyDerivationOptionsJson] string.
 *
 * Supports authenticated encryption and decryption via the [seal] and [unseal] methods.
 *
 * Can be serialized into JSON format via the [toJson] method and restored from JSON
 * by calling the constructor with a JSON string.
 *
 * This class wraps the native c++ class.
 */
class SymmetricKey private constructor(internal val nativeObjectPtr: Long) {

    companion object {
        init {
            ensureJniLoaded()
        }

        @JvmStatic external fun constructJNI(
            keyBytes: ByteArray,
            keyDerivationOptionsJson: String
        ) : Long
        @JvmStatic external fun constructJNI(
            seedString: String,
            keyDerivationOptionsJson: String
        ) : Long
        @JvmStatic external fun constructFromJsonJNI(
            symmetricKeyJson: String
        ) : Long
    }

    private external fun deleteNativeObjectPtrJNI()
    private external fun keyBytesGetterJNI(): ByteArray
    private external fun keyDerivationOptionsJsonGetterJNI(): String

    /**
     * Convert this symmetric key to JSON-format string so that it can be later reconstituted
     * by passing the string to the constructor.
     */
    external fun toJson(): String

    val keyBytes: ByteArray get() = keyBytesGetterJNI()
    val keyDerivationOptionsJson: String get() = keyDerivationOptionsJsonGetterJNI()

    /**
     * Construct this object manually by passing the [keyBytes] and the
     * [keyDerivationOptionsJson] that was used in the derivation of [keyBytes].
     */
    constructor(
        keyBytes: ByteArray,
        keyDerivationOptionsJson: String
    ) : this( constructJNI(keyBytes, keyDerivationOptionsJson) )

    /**
     * A copy constructor to prevent copying of the native pointer, which would lead
     * to a use-after-dereference pointer vulnerability
     */
    internal constructor(
        other: SymmetricKey
    ) : this(other.keyBytes, other.keyDerivationOptionsJson)

    /**
     * Construct a symmetric key from a secret [seedString], which should have enough
     * entropy to make it hard to guess (e.g. 128+ bits) and a set of public (non-secret)
     * [keyDerivationOptionsJson].
     */
    constructor(
        seedString: String,
        keyDerivationOptionsJson: String
    ) : this(constructJNI(seedString, keyDerivationOptionsJson))

    /**
     * Reconstitute a symmetric key from a JSON-formatted string ([symmetricKeyJson]) which
     * was previously generated by calling [toJson] to serialize a previous instance of the
     * secret key.
     */
    constructor(
        symmetricKeyJson: String
    ) : this(constructFromJsonJNI(symmetricKeyJson))
    
    protected fun finalize() {
        deleteNativeObjectPtrJNI()
    }

    /**
     * Use authenticated encryption to seal a [plaintext] message for secure storage or
     * transmission, so that it can later be decrypted and authenticated by calling
     * [unseal] with the same [SymmetricKey] (or a copy of the key).
     * The optional [postDecryptionInstructionsJson] can be added to attach
     * instructions/requirements to be honored on unsealing.  Unsealing will fail
     * if the [postDecryptionInstructionsJson] does not match that passed to the
     * [seal] operation.
     */
    public external fun seal(
        plaintext: ByteArray,
        postDecryptionInstructionsJson: String = ""
    ): ByteArray

    fun seal(
        plaintext: String,
        postDecryptionInstructionsJson: String = ""
    ): ByteArray = seal( plaintext.toByteArray(), postDecryptionInstructionsJson)

    /**
     * Decrypt and authenticate a message which had been sealed by [seal].
     * If [postDecryptionInstructionsJson] was set during the [seal] operation, the
     * exact same string most be provided for unsealing to succeed.
     */
    public external fun unseal(
        ciphertext: ByteArray,
        postDecryptionInstructionsJson: String = ""
    ): ByteArray


}
