package org.dicekeys.trustedapp

import org.dicekeys.crypto.seeded.*
import org.dicekeys.api.*
import org.dicekeys.keysqr.Face
import org.dicekeys.keysqr.KeySqr
import org.dicekeys.crypto.seeded.PackagedSealedMessage
import org.dicekeys.crypto.seeded.SymmetricKey
import org.dicekeys.crypto.seeded.PrivateKey

/**
 * Implements the server-side API calls and the necessary permission checks,
 * using a structure that's locally testable
 * (all intent marshalling and unmarshalling occurs outside this library.)
 *
 * Internally, all API calls only use seeds to create key or [Secret] objects,
 * and keys are generated by one of the following two functions which centralize
 * security checks:
 * [getSeedOrThrowIfClientNotAuthorized], which throws an exception if the client
 * application is not authorized to use the key or [Secret] being derived, and
 * for calls to [getPrivateKey], [getSigningKey], and [getSymmetricKey] the
 * [getSeedOrThrowIfClientsMayNotRetrieveKeysOrThisClientNotAuthorized]
 * method checks that the `clientMayRetrieveKey` key-derivation option is set to true.
 *
 * Errors are not caught, but trickle up to the caller as Exceptions
 */
class ApiCommandsWithPermissionChecks(
  private val keySqr: KeySqr<Face>,
  private val clientsApplicationId: String,
  private val askUserForApprovalOrReturnResultIfReady: (message: String) -> Boolean?
) {
  /**
   * Ensure any non-empty string ends in a "." by appending one if necessary
   */
  private fun terminateWithDot(prefix: String): String =
    if (prefix.isEmpty() || prefix.lastOrNull() == '.')
      prefix
    else
      "${prefix}."


  private fun isClientAuthorizedInFaceOfRestrictions(
    restrictions: ApiKeyDerivationOptions.Restrictions?
  ): Boolean = restrictions == null ||
    restrictions.androidPackagePrefixesAllowed.let { androidPackagePrefixesAllowed ->
      androidPackagePrefixesAllowed != null &&
        terminateWithDot(clientsApplicationId).let { clientsApplicationIdWithTrailingDot ->
          androidPackagePrefixesAllowed.any { prefix ->
            clientsApplicationIdWithTrailingDot.startsWith(terminateWithDot(prefix))
          }
        }
    }

  private fun throwIfClientNotAuthorized(
    restrictions: ApiKeyDerivationOptions.Restrictions?
  ) {
    if (!isClientAuthorizedInFaceOfRestrictions(restrictions)) {
      // The client application id does not start with any of the specified prefixes
      throw ClientPackageNotAuthorizedException(clientsApplicationId, restrictions?.androidPackagePrefixesAllowed)
    }
  }

  /**
   * Verify that either no Android prefixes were specified, or that the
   */
  private fun throwIfClientNotAuthorized(
    keyDerivationOptions: ApiKeyDerivationOptions
  ): Unit = throwIfClientNotAuthorized(keyDerivationOptions.restrictions)


  private fun getSeedOrThrowIfClientNotAuthorized(
    keyDerivationOptions: ApiKeyDerivationOptions
  ): String {
    throwIfClientNotAuthorized(keyDerivationOptions)
    return keySqr.toKeySeed(keyDerivationOptions.excludeOrientationOfFaces)
  }

  private fun getSeedOrThrowIfClientNotAuthorized(
    keyDerivationOptionsJson: String?,
    keyType: KeyDerivationOptions.KeyType
  ): String = getSeedOrThrowIfClientNotAuthorized(
    ApiKeyDerivationOptions(keyDerivationOptionsJson, keyType)
  )

  private fun getSeedOrThrowIfClientsMayNotRetrieveKeysOrThisClientNotAuthorized(
    keyDerivationOptionsJson: String?,
    keyType: KeyDerivationOptions.KeyType
  ) : String =
    with(ApiKeyDerivationOptions(keyDerivationOptionsJson, keyType), {
      if (clientMayRetrieveKey) {
        throw ClientMayNotRetrieveKeyException(keyType.name)
      }
      return getSeedOrThrowIfClientNotAuthorized(this)
    })

  private fun throwIfPostDecryptionInstructionsViolated(
    postDecryptionInstructions: PostDecryptionInstructions
  ) : Unit = throwIfClientNotAuthorized(postDecryptionInstructions.restrictions)

  /**
   * Return true if unsealing is allowed
   * Throw if it is forbidden
   * Return false if waiting on the user to make this choice
   */
  private fun isUnsealingAllowedByPostDecryptionInstructions(
    postDecryptionInstructions: PostDecryptionInstructions
  ) : Boolean? = postDecryptionInstructions.userMustAcknowledgeThisMessage.let { message ->
    throwIfPostDecryptionInstructionsViolated(postDecryptionInstructions)
    if (message == null) return true
    return askUserForApprovalOrReturnResultIfReady(message)
  }

  private fun isUnsealingAllowedByPostDecryptionInstructions(
    postDecryptionInstructions: String
  ) = isUnsealingAllowedByPostDecryptionInstructions(PostDecryptionInstructions(postDecryptionInstructions))

  private fun isUnsealingAllowedByPostDecryptionInstructions(
    packagedSealedMessage: PackagedSealedMessage
  ) = isUnsealingAllowedByPostDecryptionInstructions(packagedSealedMessage.postDecryptionInstructions)


  /**
   * Implement [DiceKeysApiClient.getSecret] with the necessary permissions checks
   */
  fun getSecret(keyDerivationOptionsJson: String): Secret =
    Secret.deriveFromSeed(
      getSeedOrThrowIfClientNotAuthorized(
        keyDerivationOptionsJson,
        KeyDerivationOptions.KeyType.Secret
      ),
      keyDerivationOptionsJson
    )

  /**
   * Implement [DiceKeysApiClient.sealWithSymmetricKey] with the necessary permissions checks
   */
  fun sealWithSymmetricKey(
    keyDerivationOptionsJson: String,
    plaintext: ByteArray,
    postDecryptionInstructions: String?
  ): PackagedSealedMessage =
    SymmetricKey.deriveFromSeed(
      getSeedOrThrowIfClientNotAuthorized(
        keyDerivationOptionsJson,
        KeyDerivationOptions.KeyType.Symmetric
      ),
      keyDerivationOptionsJson
    ).seal(plaintext, postDecryptionInstructions ?: "")

  /**
   * Implement [DiceKeysApiClient.unsealWithSymmetricKey] with the necessary permissions checks
   */
  fun unsealWithSymmetricKey(
    packagedSealedMessage: PackagedSealedMessage
  ) : ByteArray? =
    if (isUnsealingAllowedByPostDecryptionInstructions(packagedSealedMessage) == true)
      SymmetricKey.unseal(
        packagedSealedMessage,
        getSeedOrThrowIfClientNotAuthorized(
          packagedSealedMessage.keyDerivationOptionsJson,
          KeyDerivationOptions.KeyType.Symmetric
        )
      )
    else null

  /**
   * Implement [DiceKeysApiClient.getPublicKey] with the necessary permissions checks
   */
  fun getPublicKey(
    keyDerivationOptionsJson: String
  ) : PublicKey =
    PrivateKey.deriveFromSeed(
      getSeedOrThrowIfClientNotAuthorized(
        keyDerivationOptionsJson,
        KeyDerivationOptions.KeyType.Public
      ),
      keyDerivationOptionsJson
    ).getPublicKey()

  /**
   * Implement [DiceKeysApiClient.getPrivateKey] with the necessary permissions checks
   */
  fun getPrivateKey(
    keyDerivationOptionsJson: String
  ) : PrivateKey = PrivateKey.deriveFromSeed(
    getSeedOrThrowIfClientsMayNotRetrieveKeysOrThisClientNotAuthorized(
      keyDerivationOptionsJson,
      KeyDerivationOptions.KeyType.Public
    ),
    keyDerivationOptionsJson
  )

  /**
   * Implement [DiceKeysApiClient.getSigningKey] with the necessary permissions checks
   */
  fun getSigningKey(
    keyDerivationOptionsJson: String
  ) : SigningKey = SigningKey.deriveFromSeed(
    getSeedOrThrowIfClientsMayNotRetrieveKeysOrThisClientNotAuthorized(
      keyDerivationOptionsJson,
      KeyDerivationOptions.KeyType.Signing
    ),
    keyDerivationOptionsJson
  )

  /**
   * Implement [DiceKeysApiClient.getSymmetricKey] with the necessary permissions checks
   */
  fun getSymmetricKey(
    keyDerivationOptionsJson: String
  ) : SymmetricKey = SymmetricKey.deriveFromSeed(
    getSeedOrThrowIfClientsMayNotRetrieveKeysOrThisClientNotAuthorized(
      keyDerivationOptionsJson,
      KeyDerivationOptions.KeyType.Symmetric
    ),
    keyDerivationOptionsJson
  )

  /**
   * Implement [DiceKeysApiClient.getSignatureVerificationKey] with the necessary permissions checks
   */
  fun getSignatureVerificationKey(
    keyDerivationOptionsJson: String
  ) : SignatureVerificationKey =
    SigningKey.deriveFromSeed(
      getSeedOrThrowIfClientNotAuthorized(
        keyDerivationOptionsJson,
        KeyDerivationOptions.KeyType.Signing
      ),
      keyDerivationOptionsJson
    ).getSignatureVerificationKey()

  /**
   * Implement [DiceKeysApiClient.unsealWithPrivateKey] with the necessary permissions checks
   */
  fun unsealWithPrivateKey(
    packagedSealedMessage: PackagedSealedMessage
  ) : ByteArray? =
    if (isUnsealingAllowedByPostDecryptionInstructions(packagedSealedMessage) == true)
      PrivateKey.deriveFromSeed(
        getSeedOrThrowIfClientNotAuthorized(
          packagedSealedMessage.keyDerivationOptionsJson,
          KeyDerivationOptions.KeyType.Public
        ),
        packagedSealedMessage.keyDerivationOptionsJson
      ).unseal(packagedSealedMessage)
    else null

  /**
   * Implement [DiceKeysApiClient.generateSignature] with the necessary permissions checks
   */
  fun generateSignature(
    keyDerivationOptionsJson: String,
    message: ByteArray
  ): Pair<ByteArray, SignatureVerificationKey> = SigningKey.deriveFromSeed(
      getSeedOrThrowIfClientNotAuthorized(
        keyDerivationOptionsJson,
        KeyDerivationOptions.KeyType.Signing
      ),
      keyDerivationOptionsJson
    ).let{ signingKey ->
      Pair(signingKey.generateSignature(message), signingKey.getSignatureVerificationKey())
    }

}